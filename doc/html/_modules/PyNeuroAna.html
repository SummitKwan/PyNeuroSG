<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>PyNeuroAna &#8212; PyNeuroSG 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for PyNeuroAna</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">spectral</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.filters</span> <span class="k">as</span> <span class="nn">spfltr</span>
<span class="kn">import</span> <span class="nn">sklearn</span>
<span class="kn">import</span> <span class="nn">sklearn.decomposition</span> <span class="k">as</span> <span class="nn">decomposition</span>
<span class="kn">import</span> <span class="nn">sklearn.manifold</span> <span class="k">as</span> <span class="nn">manifold</span>
<span class="kn">import</span> <span class="nn">sklearn.preprocessing</span> <span class="k">as</span> <span class="nn">preprocessing</span>
<span class="kn">import</span> <span class="nn">sklearn.linear_model</span> <span class="k">as</span> <span class="nn">linear_model</span>
<span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="k">import</span> <span class="n">LinearDiscriminantAnalysis</span>
<span class="kn">import</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">as</span> <span class="nn">gaussian_process</span>
<span class="kn">import</span> <span class="nn">sklearn.model_selection</span> <span class="k">as</span> <span class="nn">model_selection</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">optimize</span>
<span class="kn">from</span> <span class="nn">robust_csd</span> <span class="k">import</span> <span class="n">cal_robust_csd</span><span class="p">,</span> <span class="n">cal_1dCSD</span><span class="p">,</span> <span class="n">lfp_robust_smooth</span>




<span class="sd">&quot;&quot;&quot; ===== basic operation: smooth and average ===== &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SmoothTrace"><a class="viewcode-back" href="../index.html#PyNeuroAna.SmoothTrace">[docs]</a><span class="k">def</span> <span class="nf">SmoothTrace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sk_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    smooth data using a gaussian kernel</span>

<span class="sd">    :param data:    a N dimensional array, default to [num_trials * num_timestamps * num_channels]</span>
<span class="sd">    :param sk_std:  smooth kernel (sk) standard deviation (std), default to None, do nothing</span>
<span class="sd">    :param fs:      sampling frequency, default to 1 Hz</span>
<span class="sd">    :param ts:      timestamps, an array, which can overwrite fs;   len(ts)==data.shape[axis] should hold,</span>
<span class="sd">    :param axis:    a axis of data along which data will be smoothed</span>
<span class="sd">    :return:        smoothed data of the same size</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>     <span class="c1"># use fs to determine ts</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>              <span class="c1"># use ts to determine fs</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">sk_std</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># condition for using smoothness kernel</span>
        <span class="n">ts_interval</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span>  <span class="c1"># get sampling interval</span>
        <span class="n">kernel_std</span> <span class="o">=</span> <span class="n">sk_std</span> <span class="o">/</span> <span class="n">ts_interval</span>  <span class="c1"># std in frames</span>
        <span class="n">kernel_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">kernel_std</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># num of frames, 3*std on each side, an odd number</span>
        <span class="n">smooth_kernel</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">kernel_len</span><span class="p">,</span> <span class="n">kernel_std</span><span class="p">)</span>
        <span class="n">smooth_kernel</span> <span class="o">=</span> <span class="n">smooth_kernel</span> <span class="o">/</span> <span class="n">smooth_kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># normalized smooth kernel</span>

        <span class="c1"># convolution using fftconvolve(), whihc is faster than convolve()</span>
        <span class="n">data_smooth</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">convolve1d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">smooth_kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_smooth</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">return</span> <span class="n">data_smooth</span></div>



<div class="viewcode-block" id="AveOverTime"><a class="viewcode-back" href="../index.html#PyNeuroAna.AveOverTime">[docs]</a><span class="k">def</span> <span class="nf">AveOverTime</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tf_count</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    smooth data using a gaussian kernel</span>

<span class="sd">    :param data:    a N dimensional array, default to [num_trials * num_timestamps * num_channels]</span>
<span class="sd">    :param t_range: range of time to compute average on, e.g. [0.050, 0.400]</span>
<span class="sd">    :param ts:      timestamps, an array, which can overwrite fs;   len(ts)==data.shape[axis] should hold,</span>
<span class="sd">    :param t_axis:  axis of data along which data will be averaged</span>
<span class="sd">    :param tf_count:True/False output spike count instead of firing rate</span>
<span class="sd">    :return:        smoothed data of the same size</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">t_axis</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">t_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_range</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># get sampling rate</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>

    <span class="n">indx_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">t_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&lt;</span> <span class="n">t_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
    <span class="n">data_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indx_in_range</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>
    <span class="n">data_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data_in_range</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tf_count</span><span class="p">:</span>
        <span class="n">data_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">data_ave</span><span class="o">/</span><span class="n">fs</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">indx_in_range</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">data_ave</span></div>


<div class="viewcode-block" id="GroupWithoutAve"><a class="viewcode-back" href="../index.html#PyNeuroAna.GroupWithoutAve">[docs]</a><span class="k">def</span> <span class="nf">GroupWithoutAve</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for data_neuro object, get average response using the groupby information</span>

<span class="sd">    :param data_neuro: data neuro object after signal_align.neuro_sort() function, contains &#39;cdtn&#39; and &#39;cdtn_indx&#39; which directs the grouping rule</span>
<span class="sd">    :param data:       data, if not give, set to data_neuro[&#39;data].  It&#39;s zero-th dimension correspond to the index of data_neuro[&#39;cdtn_indx]</span>
<span class="sd">    :return:           data_groupave, e.g. array with the size of [num_cdtn * num_ts* num_chan]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">data_group</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cdtn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn&#39;</span><span class="p">]):</span>
        <span class="c1"># ave = np.mean(np.take(data, data_neuro[&#39;cdtn_indx&#39;][cdtn], axis=0), axis=0)</span>
        <span class="n">data_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn_indx&#39;</span><span class="p">][</span><span class="n">cdtn</span><span class="p">],</span> <span class="p">:])</span>
    <span class="k">return</span> <span class="n">data_group</span></div>


<div class="viewcode-block" id="GroupStat"><a class="viewcode-back" href="../index.html#PyNeuroAna.GroupStat">[docs]</a><span class="k">def</span> <span class="nf">GroupStat</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">statfun</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">statfunargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for data_neuro object, get average response using the groupby information</span>

<span class="sd">    :param data_neuro: data neuro object after signal_align.neuro_sort() function, contains &#39;cdtn&#39; and &#39;cdtn_indx&#39; which directs the grouping rule</span>
<span class="sd">    :param data:       data, if not give, set to data_neuro[&#39;data].  It&#39;s zero-th dimension correspond to the index of data_neuro[&#39;cdtn_indx]</span>
<span class="sd">    :param statfun:    stat function to apply along axis, either strings in [&#39;mean&#39;, &#39;std&#39;, &#39;median&#39;] or function handels like np.min, note the function must contain axis argument</span>
<span class="sd">    :param statfunargs: any argument for statfun, e.g. q=20 for np.percentile</span>
<span class="sd">    :return:           data_groupstat, e.g. array with the size of [num_cdtn, :], all other dimentions are the same with data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="s1">&#39;cdtn&#39;</span> <span class="ow">in</span> <span class="n">data_neuro</span> <span class="ow">and</span> <span class="s1">&#39;cdtn_indx&#39;</span> <span class="ow">in</span> <span class="n">data_neuro</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">data_grpstat_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">data_grpstat_shape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">data_grpstat_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn&#39;</span><span class="p">])]</span> <span class="o">+</span> <span class="n">data_grpstat_shape</span>
    <span class="n">data_groupstat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_grpstat_shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">statfun</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">statfun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">elif</span> <span class="n">statfun</span> <span class="o">==</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span>
        <span class="n">statfun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span>
    <span class="k">elif</span> <span class="n">statfun</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">statfun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>

    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">statfun</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
    <span class="n">statfun_final</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">statfun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">statfunargs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cdtn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn&#39;</span><span class="p">]):</span>
        <span class="n">data_groupstat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">statfun_final</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn_indx&#39;</span><span class="p">][</span><span class="n">cdtn</span><span class="p">],</span> <span class="p">:])</span>

    <span class="k">return</span> <span class="n">data_groupstat</span></div>


<div class="viewcode-block" id="GroupAve"><a class="viewcode-back" href="../index.html#PyNeuroAna.GroupAve">[docs]</a><span class="k">def</span> <span class="nf">GroupAve</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for data_neuro object, get average response using the groupby information</span>

<span class="sd">    :param data_neuro: data neuro object after signal_align.neuro_sort() function, contains &#39;cdtn&#39; and &#39;cdtn_indx&#39; which directs the grouping rule</span>
<span class="sd">    :param data:       data, if not give, set to data_neuro[&#39;data].  It&#39;s zero-th dimension correspond to the index of data_neuro[&#39;cdtn_indx]</span>
<span class="sd">    :return:           data_groupave, e.g. array with the size of [num_cdtn * num_ts* num_chan]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">data_grpave_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">data_grpave_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn&#39;</span><span class="p">])</span>
    <span class="n">data_groupave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_grpave_shape</span><span class="p">)</span>
    <span class="n">data_groupstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_grpave_shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cdtn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn&#39;</span><span class="p">]):</span>
        <span class="n">data_groupave</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn_indx&#39;</span><span class="p">][</span><span class="n">cdtn</span><span class="p">],</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">data_groupstd</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data_neuro</span><span class="p">[</span><span class="s1">&#39;cdtn_indx&#39;</span><span class="p">][</span><span class="n">cdtn</span><span class="p">],</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_std</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_groupave</span><span class="p">,</span> <span class="n">data_groupstd</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_groupave</span></div>



<div class="viewcode-block" id="TuningCurve"><a class="viewcode-back" href="../index.html#PyNeuroAna.TuningCurve">[docs]</a><span class="k">def</span> <span class="nf">TuningCurve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stat_t</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">stat_trials</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the tuning curve of a neuron&#39;s response</span>

<span class="sd">    :param data:     2D array, [ num_trials * num_ts ]</span>
<span class="sd">    :param label:    1D array or list, [ num_trials ]</span>
<span class="sd">    :param type:     type of tuning curve, one of the following: &#39;&#39;, &#39;rank&#39;</span>
<span class="sd">    :param ts:       1D array of time stamps, [ num_ts ], default to 1 Hz sampling rate start from 0</span>
<span class="sd">    :param t_window: list, [ t_start, t_end ], if not give, use the full range</span>
<span class="sd">    :param limit:    1D array, boolean or index array, instructing whether to use a subset of trials</span>
<span class="sd">    :return:         [condition, activity], they both are 1D arrays, of the same length,</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span>  <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">limit</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">limit</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">t_window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_window</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">InRange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_range</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># get the response in the t_window</span>
    <span class="k">if</span> <span class="n">stat_t</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">InRange</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">t_window</span><span class="p">)</span> <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">stat_t</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">InRange</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">t_window</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">stat_t</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">InRange</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">t_window</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">stat_t</span> <span class="o">==</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">InRange</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">t_window</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>   <span class="c1"># stat_t is a function handle</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">stat_t</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">InRange</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">t_window</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


    <span class="c1"># get the response over trials of the same condition</span>
    <span class="k">if</span> <span class="n">stat_trials</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">stat_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">elif</span> <span class="n">stat_trials</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">stat_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>
    <span class="k">elif</span> <span class="n">stat_trials</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="n">stat_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span>
    <span class="k">elif</span> <span class="n">stat_trials</span> <span class="o">==</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span>
        <span class="n">stat_trials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stat_trials</span><span class="p">(</span><span class="n">response</span><span class="p">[</span><span class="n">label</span><span class="o">==</span><span class="n">xx</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;rank&#39;</span><span class="p">:</span>   <span class="c1"># sort in descending order</span>
        <span class="n">i_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">y</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i_sort</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i_sort</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>   <span class="c1"># sort in descending order</span>
        <span class="n">i_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i_sort</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i_sort</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>



<div class="viewcode-block" id="cal_ISI"><a class="viewcode-back" href="../index.html#PyNeuroAna.cal_ISI">[docs]</a><span class="k">def</span> <span class="nf">cal_ISI</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate inter-spike invervals</span>
<span class="sd">    :param X:    2D array of spike data (binary values), [ num_trials * num_ts ]</span>
<span class="sd">    :param ts:   timestamps of X (1D array) or sampling interval of ts (a scalar)</span>
<span class="sd">    :param bin:  bin centers for histogram</span>
<span class="sd">    :return:     (ISI, ISI_hist, bin). ISI: 1D array of all ISIs, ISI_hist: hist of ISIs, bin: bins of ISI_hist</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">&gt;</span><span class="mi">0</span>
    <span class="n">ISI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">t_interval</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_interval</span><span class="o">=</span> <span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_interval</span><span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">ISI</span> <span class="o">=</span> <span class="n">ISI</span><span class="o">*</span> <span class="n">t_interval</span>

    <span class="k">if</span> <span class="nb">bin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span><span class="o">*</span><span class="n">t_interval</span>

    <span class="p">(</span><span class="n">ISI_hist</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">ISI</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">center2edge</span><span class="p">(</span><span class="nb">bin</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ISI</span><span class="p">,</span> <span class="n">ISI_hist</span><span class="p">,</span> <span class="nb">bin</span><span class="p">)</span></div>



<div class="viewcode-block" id="cal_STA"><a class="viewcode-back" href="../index.html#PyNeuroAna.cal_STA">[docs]</a><span class="k">def</span> <span class="nf">cal_STA</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Xt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_point_zero</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate spike triggered average</span>
<span class="sd">        :param X:    2D array of data (spike or LFP), [ num_trials * num_ts ]</span>
<span class="sd">        :param Xt:   2D array of spike data used as triggers (binary data), [ num_trials * num_ts ]</span>
<span class="sd">        :param ts:   timestamps for X</span>
<span class="sd">        :param t_window:  window for STA</span>
<span class="sd">        :return:     (sta, t_sta, st), sta: 1D array of STA; t_sta: timestamps; st: spike-triggered segments, 2D array [N_spikes, N_ts]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Xt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">X</span>

    <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">t_interval</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_interval</span><span class="o">=</span> <span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_interval</span><span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">if</span> <span class="n">t_window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indx_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indx_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">t_interval</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">t_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">t_interval</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t_sta</span> <span class="o">=</span> <span class="n">indx_sta</span> <span class="o">*</span> <span class="n">t_interval</span>

    <span class="n">X_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>            <span class="c1"># data in flat form</span>
    <span class="n">Xt</span> <span class="o">=</span> <span class="n">Xt</span><span class="o">&gt;</span><span class="mi">0</span>
    <span class="n">indx_trg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>   <span class="c1"># indexes of triggers in flat form</span>

    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx_trg</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx_sta</span><span class="p">)</span>
    <span class="n">indx_trg_sta</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">indx_sta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">indx_trg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># spike triggered segments, 2D array [N_spikes, N_ts]</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">X_flat</span><span class="p">,</span> <span class="n">indx_trg_sta</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
    <span class="c1"># spike triggered average, 1D array [N_ts]</span>
    <span class="n">sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zero_point_zero</span><span class="p">:</span>
        <span class="n">sta</span><span class="p">[</span><span class="n">t_sta</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">sta</span><span class="p">,</span> <span class="n">t_sta</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot; ========== CSD estimation related ========== &quot;&quot;&quot;</span>
<span class="c1"># moved to file robutst_csd.py</span>


<span class="sd">&quot;&quot;&quot; ===== decoding related ===== &quot;&quot;&quot;</span>


<div class="viewcode-block" id="decode_over_time"><a class="viewcode-back" href="../index.html#PyNeuroAna.decode_over_time">[docs]</a><span class="k">def</span> <span class="nf">decode_over_time</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">limit_tr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit_ch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts_win_train</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; decoding realted, temporary &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="p">[</span><span class="n">N_tr</span><span class="p">,</span> <span class="n">N_ts</span><span class="p">,</span> <span class="n">N_ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="sd">&quot;&quot;&quot; normalized for every channels, so that every channel has mean=0, std=1 &quot;&quot;&quot;</span>
    <span class="n">mean_ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">std_ch</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">data_nmlz</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">mean_ch</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_ch</span>

    <span class="sd">&quot;&quot;&quot; select a subset of trials and channels &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limit_tr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limit_tr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_tr</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limit_tr</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">limit_tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">limit_tr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">limit_ch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limit_ch</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_ch</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limit_ch</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">limit_ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">limit_ch</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data_nmlz</span><span class="p">[</span><span class="n">limit_tr</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,:,</span><span class="n">limit_ch</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">limit_tr</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot; classification model &quot;&quot;&quot;</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">warm_start</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot; classification over every time point &quot;&quot;&quot;</span>
    <span class="n">clf_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_ts</span><span class="p">)</span>
    <span class="n">clf_score_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_ts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ts_win_train</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_ts</span><span class="p">):</span>
            <span class="n">cfl_scores</span> <span class="o">=</span> <span class="n">model_selection</span><span class="o">.</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">clf_score</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cfl_scores</span><span class="p">)</span>
            <span class="n">clf_score_std</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cfl_scores</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">clf_score</span></div>




<span class="sd">&quot;&quot;&quot; ===== spike point process analysis related ===== &quot;&quot;&quot;</span>


<div class="viewcode-block" id="gen_gamma_knl"><a class="viewcode-back" href="../index.html#PyNeuroAna.gen_gamma_knl">[docs]</a><span class="k">def</span> <span class="nf">gen_gamma_knl</span><span class="p">(</span><span class="n">ts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    tool function generate a gamma-distribution-like kernel (1D), used as a impulse response function</span>

<span class="sd">    could be parametrized using k and theta like Gamma distribution, or use mean and sigma like gaussian distribution.</span>
<span class="sd">    Note that mu=k*theta, sigma=sqrt(k*theta**2)</span>

<span class="sd">    e.g.  bump = gen_gamma_bump(ts, k=2, theta=0.20) is equivalent as bump = gen_gamma_bump(ts, mu=0.4, theta=0.08);</span>

<span class="sd">    :param ts:    timestamps, e.g. ts = np.arange(-0.1, 1.0, 0.001);</span>
<span class="sd">    :param k:     if parametrized as gamma: shape parameter, if 1, exp distribution, if large, becomes gaussian-like</span>
<span class="sd">    :param theta: if parametrized as gamma: scale parameter, mean = k*theta, var = k*theta**2</span>
<span class="sd">    :param mu:    alternative parametrization: mean is mu</span>
<span class="sd">    :param std:   alternative parametrization: var is std**2</span>
<span class="sd">    :return:      a gamma-like bump</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">mu</span>
        <span class="n">k</span>     <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">mu</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">ts_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">bump</span> <span class="o">=</span> <span class="n">ts_abs</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ts_abs</span><span class="o">/</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">bump</span> <span class="o">=</span> <span class="n">bump</span> <span class="o">*</span> <span class="p">(</span><span class="n">ts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalize</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">bump</span> <span class="o">=</span> <span class="n">bump</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bump</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">normalize</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="n">bump</span> <span class="o">=</span> <span class="n">bump</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bump</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bump</span></div>



<div class="viewcode-block" id="gen_knl_series"><a class="viewcode-back" href="../index.html#PyNeuroAna.gen_knl_series">[docs]</a><span class="k">def</span> <span class="nf">gen_knl_series</span><span class="p">(</span><span class="n">ts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">spacing_factor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">tf_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    tool function to generate a series of N gamma-like kernels distributed within the range defined by scale,</span>
<span class="sd">    used as the basis functions for the internal/external history term for neural point process</span>
<span class="sd">    test: plt.plot(pna.gen_bump_series().transpose())</span>

<span class="sd">    :param ts:    timestamps, e.g. ts = np.arange(-0.1, 1.0, 0.001);</span>
<span class="sd">    :param scale: scale of the bumps, which defines the mean of the broadest gamma bump</span>
<span class="sd">    :param N:     number of bumps</span>
<span class="sd">    :param spacing_factor: any number &gt;=1, default to sqrt(2), if small, evenly spaces, if large, un-evenly spaced</span>
<span class="sd">    :param tf_symmetry: True or False, make ts symmetric about zero</span>
<span class="sd">    :return:      2D array of bump series, [N_bumps, N_ts]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">tf_symmetry</span><span class="p">:</span>    <span class="c1"># make sure that ts is symmetric about zero, convenient for convolution</span>
        <span class="n">t_interval</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
        <span class="n">h_len_knl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t_max</span><span class="o">/</span><span class="n">t_interval</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">h_len_knl</span><span class="p">,</span> <span class="n">h_len_knl</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">t_interval</span>

    <span class="c1"># k of gamma is exponent with base=spacing_factor</span>
    <span class="n">list_k</span> <span class="o">=</span> <span class="n">spacing_factor</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># theta of gamma makes the mean of the largest gamma equal to scale</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">scale</span><span class="o">/</span><span class="n">list_k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># generate gamma series</span>
    <span class="n">knl_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gen_gamma_knl</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">list_k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">knl_series</span></div>



<div class="viewcode-block" id="gen_delta_function_with_label"><a class="viewcode-back" href="../index.html#PyNeuroAna.gen_delta_function_with_label">[docs]</a><span class="k">def</span> <span class="nf">gen_delta_function_with_label</span><span class="p">(</span><span class="n">ts</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span> <span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                       <span class="n">tf_y_ctgr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tf_return_ctgr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate delta function at time t and with label y for every trial on time grid ts</span>

<span class="sd">    :param ts:   timestamps, grid of time, of length T</span>
<span class="sd">    :param t:    time of event onset of every trial, of length N, if the same across all trials, could be given as a scalar</span>
<span class="sd">    :param y:    labels of events, of length N: if tf_return_ctgr==True, could be any type; otherwise, must be numbers.</span>
<span class="sd">                    if the same across trials, could be given as a scalar</span>
<span class="sd">    :param tf_y_ctgr:      True/False of y being categorical</span>
<span class="sd">    :param tf_return_ctgr: True/False to return y cetegory lables</span>
<span class="sd">    :return:     delta_fun or (delta_fun, y_ctgy)</span>

<span class="sd">                    delta_fun if tf_return_ctgr==False, (delta_fun, y_ctgy) otherwise</span>

<span class="sd">                    detta_fun is [N*T] if tf_y_ctgr==False, [N*T*M] if tf</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="sd">&quot;&quot;&quot;  pre-process t and y, make sure that they are 1D array of lenth N  &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>         <span class="c1"># if t is scalar, repeat N times</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>         <span class="c1"># if y is scalar, repeat N times</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>    <span class="c1"># if t and y are of different lengths</span>
        <span class="k">raise</span><span class="p">(</span><span class="s1">&#39;input t and y should be of the same length&#39;</span><span class="p">)</span>


    <span class="sd">&quot;&quot;&quot; produce Y: if y is continuous, make it [N*1]; if y is categorical (M categories), make it [N*M] binary values &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tf_y_ctgr</span><span class="p">:</span>
        <span class="n">label_enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
        <span class="n">enc</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">y_code</span> <span class="o">=</span> <span class="n">label_enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span> <span class="n">y_code</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">Y_label</span> <span class="o">=</span> <span class="n">label_enc</span><span class="o">.</span><span class="n">classes_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Y_label</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span>


    <span class="sd">&quot;&quot;&quot; generate gamma functions &quot;&quot;&quot;</span>
    <span class="n">delta_fun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span>
    <span class="n">i_t</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">ts</span><span class="o">-</span><span class="n">t_one</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="k">for</span> <span class="n">t_one</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>
    <span class="n">delta_fun</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">i_t</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">tf_y_ctgr</span><span class="p">:</span>
        <span class="n">delta_fun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">delta_fun</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[:,</span> <span class="n">m</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">delta_fun</span> <span class="o">*=</span> <span class="n">Y</span>

    <span class="k">if</span> <span class="n">tf_return_ctgr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">delta_fun</span><span class="p">,</span> <span class="n">Y_label</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">delta_fun</span></div>


<div class="viewcode-block" id="fit_neural_point_process"><a class="viewcode-back" href="../index.html#PyNeuroAna.fit_neural_point_process">[docs]</a><span class="k">def</span> <span class="nf">fit_neural_point_process</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Xs</span><span class="p">,</span> <span class="n">Xs_knls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fit neural point process, based on Truccolo W, Eden UT, Fellows MR, Donoghue JP, Brown EN (2005) A point process framework for relating neural spiking activity to spiking history, neural ensemble and extrinsic covariate effects. J Neurophysiology, 93, 1074-1089.</span>

<span class="sd">    :param Y:       Y to be predicted, binary, 2D of shape [N, T], N trials, T timestamps</span>
<span class="sd">    :param Xs:      Xs, used to predict Y, list of 2D arrays, where every array is of the same shape as Y</span>
<span class="sd">    :param Xs_knls: kernels for Xs, a list, where Xs_kernel[i] is a 2D array correspond to Xs[i],</span>
<span class="sd">                        Xs_kernel[i] is of shape [num_kernels, num_ts_for_kernel], every kernel works as the inpulse-response function, centered at zero</span>
<span class="sd">    :return:        regression object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="sd">&quot;&quot;&quot; make sure Y is binary; Xs, Xs_knls are lists &quot;&quot;&quot;</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Y</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Xs</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">list</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Xs</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Xs_knls</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">list</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">Xs_knls</span> <span class="o">=</span> <span class="p">[</span><span class="n">Xs_knls</span><span class="p">]</span>

    <span class="sd">&quot;&quot;&quot; X_base for fitting: [N,T,M], N trials, T time stamps, M total features  &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Ms</span><span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">history_term</span><span class="p">)</span> <span class="k">for</span> <span class="n">history_term</span> <span class="ow">in</span> <span class="n">Xs_knls</span><span class="p">]</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ms</span><span class="p">))</span>
    <span class="n">X_base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>

    <span class="sd">&quot;&quot;&quot; construct X_base, X_base[:,:,i] is the convolution of X and one kernel from the kernels for X &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Xs</span><span class="p">):</span>                 <span class="c1"># for every X</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">knl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Xs_knls</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>   <span class="c1"># for every kernel</span>
            <span class="n">X_base</span><span class="p">[:,:,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">spfltr</span><span class="o">.</span><span class="n">convolve1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">knl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># convolve along time axis</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="sd">&quot;&quot;&quot; GML regression, here logistic regression for binary Y &quot;&quot;&quot;</span>
    <span class="n">reg_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X_base</span><span class="p">,</span> <span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>   <span class="c1"># re-organized for regression, shape 2D: [N*T, M]</span>
    <span class="n">reg_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="n">T</span><span class="p">])</span>           <span class="c1"># re-organized for regression, shape 1D: [N*T]</span>

    <span class="n">reg</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LogisticRegression</span><span class="p">()</span>  <span class="c1"># regression model using sklearn</span>
    <span class="n">reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">reg_X</span><span class="p">,</span> <span class="n">reg_y</span><span class="p">)</span>                    <span class="c1"># fit</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">reg_X</span><span class="p">,</span> <span class="n">reg_y</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reg</span></div>



<span class="sd">&quot;&quot;&quot; ===== spectral analysis ===== &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">ComputeWelchSpectrum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">t_ini</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">t_axis</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">t_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>      <span class="c1"># get the data of interest</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data1</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>
        <span class="n">t_ini</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">ts</span><span class="o">&gt;=</span><span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

    <span class="p">[</span><span class="n">spcg</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span> <span class="n">t_axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">,</span>
                       <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>

    <span class="n">spct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spct</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">ComputeWelchCoherence</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">t_ini</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">t_axis</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">t_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>      <span class="c1"># get the data of interest</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data1</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">t_window</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>
        <span class="n">t_ini</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">ts</span><span class="o">&gt;=</span><span class="n">t_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

    <span class="p">[</span><span class="n">cohg</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeCoherogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span>
                       <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>

    <span class="n">cohe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cohg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">cohe</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span>


<div class="viewcode-block" id="ComputeSpectrogram"><a class="viewcode-back" href="../index.html#PyNeuroAna.ComputeSpectrogram">[docs]</a><span class="k">def</span> <span class="nf">ComputeSpectrogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compuate power spectrogram in sliding windows</span>

<span class="sd">    if a single data is give, returns power spectrum density Pxx over sliding windows;</span>
<span class="sd">    if two data are given, returns cross spectrum Pxy over sliding windows</span>

<span class="sd">    :param data:     LFP data, [ trials * timestamps * channels]</span>
<span class="sd">                            the dimension does not matter, as long as the time axis is provided in t_axis;</span>
<span class="sd">                            the resulting spcg will add another dimension (frequency) to the end</span>
<span class="sd">    :param fs:       sampling frequency</span>
<span class="sd">    :param t_ini:    the first timestamps</span>
<span class="sd">    :param t_bin:    duration of time bin for fft, will be used to find the nearest power of two, default to total_time/10</span>
<span class="sd">    :param t_step:   step size for moving window, default to t_bin / 8</span>
<span class="sd">    :param t_axis:   the axis index of the time in data</span>
<span class="sd">    :param batchsize: to prevent memory overloading problem (default to 100, make smaller if memory overload occurs)</span>
<span class="sd">    :param f_lim:    frequency limit to keep, [f_min, f_max], default to None</span>
<span class="sd">    :return:         [spcg, spcg_t, spcg_f]</span>

<span class="sd">           * spcg:     power spectogram, [ trials * frequencty * channels * timestamps] or [ trials * frequencty * timestamps]</span>
<span class="sd">           * spcg_t:   timestamps of spectrogram</span>
<span class="sd">           * spcg_f:   frequency ticks of spectrogram</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">t_bin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>     <span class="c1"># default to total_time/10</span>
        <span class="n">t_bin</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">t_axis</span><span class="p">]</span><span class="o">/</span><span class="n">fs</span> <span class="o">/</span><span class="mi">10</span>

    <span class="n">nperseg</span> <span class="o">=</span> <span class="n">GetNearestPow2</span><span class="p">(</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">t_bin</span> <span class="p">)</span>                    <span class="c1"># number of points per segment, power of 2</span>
    <span class="k">if</span> <span class="n">t_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                        <span class="c1"># number of overlapping points of neighboring segments</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nperseg</span> <span class="o">*</span> <span class="mf">0.875</span><span class="p">)</span> <span class="p">)</span>                <span class="c1"># default 7/8 overlapping</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">-</span> <span class="n">GetNearestPow2</span><span class="p">(</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">t_step</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="o">&gt;</span> <span class="n">nperseg</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span>

    <span class="n">nfft</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">*</span> <span class="mi">4</span>                        <span class="c1"># number of points for fft, determines the frequency resolution</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="n">nperseg</span><span class="p">)</span>             <span class="c1"># time window for fft</span>

    <span class="sd">&quot;&quot;&quot; compute spectrogram, use batches to prevent memory overload &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">batchsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">spcg_f</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">,</span>
                                                    <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">[</span><span class="n">spcg_f</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">_spectral_helper</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">,</span>
                                                        <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                                                                      <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;psd&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">N_trial</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">N_batch</span> <span class="o">=</span> <span class="n">N_trial</span> <span class="o">//</span> <span class="n">batchsize</span>
        <span class="k">if</span> <span class="n">N_batch</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">N_batch</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">list_indx_in_batch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_trial</span><span class="p">),</span> <span class="n">N_batch</span><span class="p">)</span>
        <span class="n">spcg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">indx_in_batch</span> <span class="ow">in</span> <span class="n">list_indx_in_batch</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="p">[</span><span class="n">spcg_f</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">indx_in_batch</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                                            <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">,</span>
                                                        <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">[</span><span class="n">spcg_f</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">_spectral_helper</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">indx_in_batch</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                                                          <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="n">indx_in_batch</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                                                          <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">,</span>
                                                                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                                                                              <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;psd&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spcg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spcg</span> <span class="o">=</span> <span class="n">spcg_cur</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">spcg</span><span class="p">,</span> <span class="n">spcg_cur</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">spcg_cur</span>    <span class="c1"># release memory</span>

    <span class="n">spcg_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spcg_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">t_ini</span>
    <span class="n">spcg_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spcg_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">f_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indx_f_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span> <span class="p">(</span><span class="n">spcg_f</span><span class="o">&gt;=</span><span class="n">f_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">spcg_f</span><span class="o">&lt;</span><span class="n">f_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>
        <span class="n">spcg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">spcg</span><span class="p">,</span> <span class="n">indx_f_keep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">t_axis</span><span class="p">)</span>
        <span class="n">spcg_f</span> <span class="o">=</span> <span class="n">spcg_f</span><span class="p">[</span><span class="n">indx_f_keep</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">spcg</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span></div>



<div class="viewcode-block" id="ComputeCoherogram"><a class="viewcode-back" href="../index.html#PyNeuroAna.ComputeCoherogram">[docs]</a><span class="k">def</span> <span class="nf">ComputeCoherogram</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                      <span class="n">tf_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tf_shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tf_vs_shuffle</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">data0_spcg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data1_spcg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data0_spcg_ave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data1_spcg_ave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data01_spcg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compuate LFP-LFP coherence over sliding window, takes two [ trials * timestamps] arrays, or one [ trials * timestamps * 2] arrays</span>

<span class="sd">    :param data0:    LFP data, [ trials * timestamps]; if data1 is None, data0 contains both signals [ trials * timestamps * 2]</span>
<span class="sd">    :param data1:    LFP data, [ trials * timestamps]</span>
<span class="sd">    :param fs:       sampling frequency</span>
<span class="sd">    :param t_ini:    the first timestamps</span>
<span class="sd">    :param t_bin:    duration of time bin for fft, will be used to find the nearest power of two</span>
<span class="sd">    :param t_step:   step size for moving window, default to t_bin / 8</span>
<span class="sd">    :param tf_phase: true/false keep phase, if true, returning value cohg is complex, whose abs represents coherence, and whose angle represents phase (negative if data1 lags data0)</span>
<span class="sd">    :param t_axis:   the axis index of the time in data</span>
<span class="sd">    :param data0_spcg: the spcg_xx, if already calculated</span>
<span class="sd">    :param data1_spcg: the spcg_yy, if already calculated</span>
<span class="sd">    :return:         [cohg, spcg_t, spcg_f]</span>

<span class="sd">           * cohg:     power spectogram, [ frequencty * timestamps ]</span>
<span class="sd">           * spcg_t:   timestamps of spectrogram</span>
<span class="sd">           * spcg_t:   frequency ticks of spectrogram</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">data1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>    <span class="c1"># the input could be data0 contains both signals, and data1 is None</span>
        <span class="k">if</span> <span class="n">data0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data0</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">data0</span> <span class="o">=</span> <span class="n">data0</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tf_vs_shuffle</span><span class="p">:</span>
        <span class="n">tf_shuffle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">tf_phase</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Pxx</span>
    <span class="k">if</span> <span class="n">data0_spcg_ave</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data0_spcg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">spcg_xx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spcg_xx</span> <span class="o">=</span> <span class="n">data0_spcg</span>
        <span class="n">spcg_xx_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_xx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spcg_xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">spcg_xx_ave</span> <span class="o">=</span> <span class="n">data0_spcg_ave</span>
    <span class="c1"># Pyy</span>
    <span class="k">if</span> <span class="n">data1_spcg_ave</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data1_spcg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">spcg_yy</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spcg_yy</span> <span class="o">=</span> <span class="n">data1_spcg</span>
        <span class="n">spcg_yy_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_yy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spcg_yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">spcg_yy_ave</span> <span class="o">=</span> <span class="n">data1_spcg_ave</span>
    <span class="c1"># Pxy</span>
    <span class="p">[</span><span class="n">spcg_xy</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>

    <span class="n">spcg_xy_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_xy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># coherence</span>
    <span class="n">cohg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spcg_xy_ave</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">spcg_xx_ave</span>  <span class="o">*</span>  <span class="n">spcg_yy_ave</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tf_shuffle</span><span class="p">:</span>
        <span class="n">data0_shuffle</span> <span class="o">=</span> <span class="n">data0</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">data0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:]</span>
        <span class="p">[</span><span class="n">spcg_xy_shuffle</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data0_shuffle</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span>
                                                       <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
        <span class="n">spcg_xy_ave_shuffle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_xy_shuffle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cohg_shuffle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spcg_xy_ave_shuffle</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">spcg_xx_ave</span>  <span class="o">*</span>  <span class="n">spcg_yy_ave</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tf_vs_shuffle</span><span class="p">:</span>
            <span class="n">cohg</span> <span class="o">=</span> <span class="n">cohg</span><span class="o">-</span><span class="n">cohg_shuffle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cohg</span> <span class="o">=</span> <span class="n">cohg_shuffle</span>

    <span class="c1"># if keeps phase, returns complex values, whose abs represents coherence, and whose angle represents phase (negative if data1 lags data0)</span>
    <span class="k">if</span> <span class="n">tf_phase</span><span class="p">:</span>
        <span class="n">cohg</span> <span class="o">=</span> <span class="n">cohg</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">spcg_xy_ave</span><span class="p">)</span> <span class="o">*</span><span class="mi">1</span><span class="n">j</span> <span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">cohg</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span></div>




<div class="viewcode-block" id="ComputeSpcgMultiPair"><a class="viewcode-back" href="../index.html#PyNeuroAna.ComputeSpcgMultiPair">[docs]</a><span class="k">def</span> <span class="nf">ComputeSpcgMultiPair</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ch_list0</span><span class="p">,</span> <span class="n">ch_list1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batchsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                      <span class="n">tf_shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tf_vs_shuffle</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tf_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute LFP spectrograms and cross-specgrograms over sliding window for all given pairs of channels,</span>
<span class="sd">    returns a dictionary containing all related info,</span>
<span class="sd">    This funciton calls the</span>
<span class="sd">    useful for computing coherence flexibly later using function ComputeCohgFromIntermediate()</span>
<span class="sd">    :param data:         LFP arrays of all channels, of shape [N_trials, N_ts]</span>
<span class="sd">    :param ch_list0:</span>
<span class="sd">    :param ch_list1:</span>
<span class="sd">    :param fs:</span>
<span class="sd">    :param t_ini:</span>
<span class="sd">    :param t_bin:</span>
<span class="sd">    :param t_step:</span>
<span class="sd">    :param f_lim:</span>
<span class="sd">    :param batchsize:</span>
<span class="sd">    :param tf_shuffle:</span>
<span class="sd">    :param tf_vs_shuffle:</span>
<span class="sd">    :param tf_verbose:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spcg_xx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">spcg_yy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">spcg_xy</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">tf_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;compute xx&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch0</span> <span class="ow">in</span> <span class="n">ch_list0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tf_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ch0</span><span class="p">)</span>
        <span class="n">data0</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,:,</span><span class="n">ch0</span><span class="p">]</span>
        <span class="p">[</span><span class="n">spcg_xx_cur</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span>
                                                 <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
        <span class="n">spcg_xx</span><span class="p">[</span><span class="n">ch0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_xx_cur</span>
    <span class="k">if</span> <span class="n">tf_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;compute yy&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="n">ch_list1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tf_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ch1</span><span class="p">)</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,:,</span><span class="n">ch1</span><span class="p">]</span>
        <span class="p">[</span><span class="n">spcg_yy_cur</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span>
                                                 <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
        <span class="n">spcg_yy</span><span class="p">[</span><span class="n">ch1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_yy_cur</span>
    <span class="k">if</span> <span class="n">tf_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;compute xy&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch0</span> <span class="ow">in</span> <span class="n">ch_list0</span><span class="p">:</span>
        <span class="n">data0</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ch0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="n">ch_list1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tf_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ch0</span><span class="p">,</span> <span class="n">ch1</span><span class="p">)</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ch1</span><span class="p">]</span>
            <span class="p">[</span><span class="n">spcg_xy_cur</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span>
                                                     <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
            <span class="n">spcg_xy</span><span class="p">[(</span><span class="n">ch0</span><span class="p">,</span> <span class="n">ch1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">spcg_xy_cur</span>
    <span class="n">spcg_multipair</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;ch_list0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_list0</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;ch_list1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_list1</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_xx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_xx</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_yy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_yy</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_xy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_xy</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_t</span>
    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spcg_f</span>

    <span class="k">return</span> <span class="n">spcg_multipair</span></div>

<span class="k">def</span> <span class="nf">ComputeCohgFromIntermediate</span><span class="p">(</span><span class="n">spcg_multipair</span><span class="p">,</span> <span class="n">limit_trial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tf_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">limit_trial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limit_trial</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_xx&#39;</span><span class="p">][</span><span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;ch_list0&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;cohg&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>

    <span class="k">for</span> <span class="n">ch0</span> <span class="ow">in</span> <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;ch_list0&#39;</span><span class="p">]:</span>
        <span class="n">spcg_xx_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_xx&#39;</span><span class="p">][</span><span class="n">ch0</span><span class="p">][</span><span class="n">limit_trial</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;ch_list1&#39;</span><span class="p">]:</span>
            <span class="n">spcg_yy_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_yy&#39;</span><span class="p">][</span><span class="n">ch1</span><span class="p">][</span><span class="n">limit_trial</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">spcg_xy_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;spcg_xy&#39;</span><span class="p">][(</span><span class="n">ch0</span><span class="p">,</span><span class="n">ch1</span><span class="p">)][</span><span class="n">limit_trial</span><span class="p">,:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># coherence</span>
            <span class="n">cohg_cur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spcg_xy_ave</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">spcg_xx_ave</span> <span class="o">*</span> <span class="n">spcg_yy_ave</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tf_phase</span><span class="p">:</span>
                <span class="n">cohg_cur</span> <span class="o">=</span> <span class="n">cohg_cur</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">spcg_xy_ave</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
            <span class="n">spcg_multipair</span><span class="p">[</span><span class="s1">&#39;cohg&#39;</span><span class="p">][(</span><span class="n">ch0</span><span class="p">,</span><span class="n">ch1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cohg_cur</span>

    <span class="k">return</span> <span class="n">spcg_multipair</span>



<div class="viewcode-block" id="ComputeSpkTrnFieldCoupling"><a class="viewcode-back" href="../index.html#PyNeuroAna.ComputeSpkTrnFieldCoupling">[docs]</a><span class="k">def</span> <span class="nf">ComputeSpkTrnFieldCoupling</span><span class="p">(</span><span class="n">data_LFP</span><span class="p">,</span> <span class="n">data_spk</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;PLV&#39;</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">batchsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tf_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tf_shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tf_vs_shuffle</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compuate spk-LFP coherence over sliding window, takes two [ trials * timestamps] arrays, or one [ trials * timestamps * 2] arrays</span>

<span class="sd">    based on paper: Vinck, M., Battaglia, F. P., Womelsdorf, T., &amp; Pennartz, C. (2012). Improved measures of phase-coupling between spikes and the Local Field Potential</span>

<span class="sd">    :param data_LFP: LFP data, [ trials * timestamps]; if data_spk is None, dataLFP contains both signals [ trials * timestamps * 2]</span>
<span class="sd">    :param data_spk: spike data, [ trials * timestamps]</span>
<span class="sd">    :param fs:       sampling frequency</span>
<span class="sd">    :param measure:  what measures to use for spk-field coupling, &#39;PLV&#39; (phase lock value, 1st order) or &#39;PPC&#39; (pairwise phase consisntency, 2nd order)</span>
<span class="sd">    :param t_ini:    the first timestamps</span>
<span class="sd">    :param t_bin:    duration of time bin for fft, will be used to find the nearest power of two</span>
<span class="sd">    :param t_step:   step size for moving window, default to t_bin / 8</span>
<span class="sd">    :param t_axis:   the axis index of the time in data</span>
<span class="sd">    :param batchsize:process a a subset of trials at a time, to prevent memory overload</span>
<span class="sd">    :param tf_phase: true/false keep phase, if true, returning value coupling_value is complex, whose abs represents coupling value, and whose angle represents phase (positive if spk leads LFP)</span>
<span class="sd">    :param f_lim:    frequency limit</span>
<span class="sd">    :return:         [cohg, spcg_t, spcg_f]</span>

<span class="sd">           * cohg:     power spectogram, [ frequencty * timestamps ]</span>
<span class="sd">           * spcg_t:   timestamps of spectrogram</span>
<span class="sd">           * spcg_t:   frequency ticks of spectrogram</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">data_spk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>    <span class="c1"># the input could be data0 contains both signals, and data1 is None</span>
        <span class="k">if</span> <span class="n">data_LFP</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">data_spk</span> <span class="o">=</span> <span class="n">data_LFP</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">data_LFP</span> <span class="o">=</span> <span class="n">data_LFP</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">data_spk</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_spk</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">N_trial</span> <span class="o">=</span> <span class="n">data_spk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tf_vs_shuffle</span><span class="p">:</span>
        <span class="n">tf_shuffle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">tf_phase</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">ComputeCouplingValue</span><span class="p">(</span><span class="n">data_LFP</span><span class="p">):</span>
        <span class="c1"># Pxy</span>
        <span class="p">[</span><span class="n">spcg_xy</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data_LFP</span><span class="p">,</span> <span class="n">data_spk</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span>
                                                       <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>

        <span class="c1"># mask for blank windows (time window without spikes)</span>
        <span class="p">[</span><span class="n">spcg_yy</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeSpectrogram</span><span class="p">(</span><span class="n">data_spk</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="n">t_ini</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="n">t_bin</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="n">t_step</span><span class="p">,</span>
                                                       <span class="n">batchsize</span><span class="o">=</span><span class="n">batchsize</span><span class="p">,</span> <span class="n">f_lim</span><span class="o">=</span><span class="n">f_lim</span><span class="p">)</span>
        <span class="n">mask_spk_exist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">spcg_yy</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># get unit vectors X (complex values), (abs=0 if the window does not contain any spikes)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">spcg_xy</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask_spk_exist</span>

        <span class="c1"># comupute spiketrian-field phase lock value (PLV) (Figure 2 of paper)</span>
        <span class="n">PLV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">N_trial</span>

        <span class="k">if</span> <span class="n">measure</span> <span class="o">==</span> <span class="s1">&#39;PLV&#39;</span><span class="p">:</span>      <span class="c1"># ----- spiketrian-field phase lock value (PLV) (Figure 2 of paper) -----</span>
            <span class="n">coupling_value</span> <span class="o">=</span> <span class="n">PLV</span>
            <span class="k">if</span> <span class="n">tf_phase</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">coupling_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">PLV</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">measure</span> <span class="o">==</span> <span class="s1">&#39;PPC&#39;</span><span class="p">:</span>    <span class="c1"># ----- spiketrian-field pairwise phase consistancy (PPC) (equation 5.6 of paper) -----</span>
            <span class="n">PPC_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">X_real</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">real</span>
            <span class="n">X_imag</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">imag</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_trial</span><span class="p">):</span>     <span class="c1"># dot product for every pair of trials</span>
                <span class="n">j</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N_trial</span><span class="p">)</span>
                <span class="n">PPC_sum</span> <span class="o">=</span> <span class="n">PPC_sum</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">X_real</span><span class="p">[[</span><span class="n">i</span><span class="p">],:,:]</span><span class="o">*</span><span class="n">X_real</span><span class="p">[</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">X_imag</span><span class="p">[[</span><span class="n">i</span><span class="p">],:,:]</span><span class="o">*</span><span class="n">X_imag</span><span class="p">[</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
            <span class="n">PPC</span> <span class="o">=</span> <span class="n">PPC_sum</span><span class="o">/</span><span class="p">(</span><span class="n">N_trial</span><span class="o">*</span><span class="p">(</span><span class="n">N_trial</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tf_phase</span><span class="p">:</span>
                <span class="n">PPC</span> <span class="o">=</span> <span class="n">PPC</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">PLV</span><span class="p">))</span>   <span class="c1"># add phase component from PLV</span>
            <span class="n">coupling_value</span> <span class="o">=</span> <span class="n">PPC</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coupling_value</span> <span class="o">=</span> <span class="n">PLV</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">coupling_value</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tf_shuffle</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="p">[</span><span class="n">coupling_value</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeCouplingValue</span><span class="p">(</span><span class="n">data_LFP</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="p">[</span><span class="n">coupling_value_shuffle</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeCouplingValue</span><span class="p">(</span><span class="n">data_LFP</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">data_LFP</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:])</span>
        <span class="k">if</span> <span class="n">tf_vs_shuffle</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="p">[</span><span class="n">coupling_value</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">ComputeCouplingValue</span><span class="p">(</span><span class="n">data_LFP</span><span class="p">)</span>
            <span class="n">coupling_value</span> <span class="o">=</span> <span class="n">coupling_value</span> <span class="o">-</span> <span class="n">coupling_value_shuffle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coupling_value</span> <span class="o">=</span> <span class="n">coupling_value_shuffle</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">coupling_value</span><span class="p">,</span> <span class="n">spcg_t</span><span class="p">,</span> <span class="n">spcg_f</span><span class="p">]</span></div>



<div class="viewcode-block" id="GetNearestPow2"><a class="viewcode-back" href="../index.html#PyNeuroAna.GetNearestPow2">[docs]</a><span class="k">def</span> <span class="nf">GetNearestPow2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the nearest power of 2, for FFT</span>

<span class="sd">    :param n:  input number</span>
<span class="sd">    :return:   an int, power of 2 (e.g., 2,4,8,16,32...), nearest to n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span></div>



<div class="viewcode-block" id="ComputeCrossCorlg"><a class="viewcode-back" href="../index.html#PyNeuroAna.ComputeCrossCorlg">[docs]</a><span class="k">def</span> <span class="nf">ComputeCrossCorlg</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">t_ini</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t_bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Cross-correlogram</span>

<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">t_bin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>     <span class="c1"># default to total_time/10</span>
        <span class="n">t_bin</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">data0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">t_axis</span><span class="p">]</span><span class="o">/</span><span class="n">fs</span> <span class="o">/</span><span class="mi">10</span>

    <span class="n">nperseg</span> <span class="o">=</span> <span class="n">GetNearestPow2</span><span class="p">(</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">t_bin</span> <span class="p">)</span>                    <span class="c1"># number of points per segment, power of 2</span>
    <span class="k">if</span> <span class="n">t_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>                                        <span class="c1"># number of overlapping points of neighboring segments</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nperseg</span> <span class="o">*</span> <span class="mf">0.875</span><span class="p">)</span> <span class="p">)</span>                <span class="c1"># default 7/8 overlapping</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">-</span> <span class="n">GetNearestPow2</span><span class="p">(</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">t_step</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="o">&gt;</span> <span class="n">nperseg</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span>

    <span class="n">data0_str</span> <span class="o">=</span> <span class="n">create_strided_array</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">)</span>
    <span class="n">data1_str</span> <span class="o">=</span> <span class="n">create_strided_array</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">)</span>

    <span class="n">t_grid</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data0_str</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">nperseg</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">nperseg</span><span class="o">/</span><span class="n">fs</span>
    <span class="n">t_segm</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nperseg</span><span class="p">)</span><span class="o">-</span><span class="n">nperseg</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="n">fs</span>

    <span class="n">corss_corlg</span> <span class="o">=</span> <span class="n">data1_str</span><span class="o">*</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corss_corlg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corss_corlg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">corss_corlg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">data0_str</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:],</span> <span class="n">data1_str</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">corss_corlg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">t_segm</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">create_strided_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">):</span>
    <span class="c1"># Created strided array of data segments, from scipy.spectral._fft_helper</span>
    <span class="k">if</span> <span class="n">nperseg</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">noverlap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">-</span> <span class="n">noverlap</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">noverlap</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span><span class="p">,</span> <span class="n">nperseg</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>




<span class="sd">&quot;&quot;&quot;  ===== simple statistics ===== &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ErrIntvBinom"><a class="viewcode-back" href="../index.html#PyNeuroAna.ErrIntvBinom">[docs]</a><span class="k">def</span> <span class="nf">ErrIntvBinom</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tf_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute the confidence interval / error interval to estimate the probability p of binomial distribution, using grid search</span>

<span class="sd">    :param k:      int, number of samples==1</span>
<span class="sd">    :param n:      int, total number of samples</span>
<span class="sd">    :param alpha:  default to 0.05, confidence level</span>
<span class="sd">    :param x:      data array, used if k and n are not given:  k=sum(x==1), n=len(x)</span>
<span class="sd">    :param tf_err: True/False to return a) err interval (confidence_interval - p) or b) confidence interval</span>
<span class="sd">    :return:       (error_low, error_hight) or (p_low, p_high)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="sd">&quot;&quot;&quot; if n, k are not given, use x to get n and k &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>   <span class="c1"># if empty</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
    <span class="sd">&quot;&quot;&quot; best estimate of p &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">n</span>
    <span class="sd">&quot;&quot;&quot; use grid search to compute confidence interval &quot;&quot;&quot;</span>
    <span class="n">p_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1001</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                <span class="c1"># grid of p</span>
    <span class="n">P_l</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p_grid</span><span class="p">)</span>                <span class="c1"># P(k or less success out of n trials)</span>
    <span class="n">P_r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">binom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p_grid</span><span class="p">)</span>            <span class="c1"># P(k or more success out of n trials)</span>
    <span class="n">intv_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_grid</span><span class="p">[</span><span class="n">P_r</span> <span class="o">&lt;=</span> <span class="n">alpha</span><span class="o">*</span><span class="mf">0.5</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">.</span><span class="n">max</span><span class="p">()</span>    <span class="c1"># lower bound of p est: k or k+ success very rare</span>
    <span class="n">intv_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_grid</span><span class="p">[</span><span class="n">P_l</span> <span class="o">&lt;=</span> <span class="n">alpha</span><span class="o">*</span><span class="mf">0.5</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">.</span><span class="n">min</span><span class="p">()</span>    <span class="c1"># upper bound of p est: k or k- success very rare</span>
    <span class="n">intv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intv_l</span><span class="p">,</span> <span class="n">intv_h</span><span class="p">])</span>                           <span class="c1"># confidence interval of p estimate</span>
    <span class="k">if</span> <span class="n">tf_err</span><span class="p">:</span>                                              <span class="c1"># if returns error inverval</span>
        <span class="k">return</span> <span class="n">intv</span> <span class="o">-</span> <span class="n">p</span>                                         <span class="c1"># error interval of p estimate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">intv</span>                                             <span class="c1"># confidence interval of p estimate</span></div>


<div class="viewcode-block" id="cal_CohenD"><a class="viewcode-back" href="../index.html#PyNeuroAna.cal_CohenD">[docs]</a><span class="k">def</span> <span class="nf">cal_CohenD</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">type_test</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate Cohen&#39;s d statistic for measuring effect size, as a complimentary test for t-test</span>

<span class="sd">    :param data0: a group of data</span>
<span class="sd">    :param data1: another group of data</span>
<span class="sd">    :param axis:  along which axis to compute d statistic</span>
<span class="sd">    :param type_test:  &#39;auto&#39;, &#39;one-sample&#39;, &#39;independent&#39;, or &#39;paired&#39;</span>

<span class="sd">         1) &#39;auto&#39;: determine based on the data input:</span>
<span class="sd">         use &#39;one-sample&#39; if only data0 is give;</span>
<span class="sd">         use &#39;paired&#39; if two data are of the same size; and</span>
<span class="sd">         use &#39;independent&#39; if two data inputs are of different sizes</span>

<span class="sd">         2) &#39;one-sample&#39;: compute one-sample d stat using only data0</span>

<span class="sd">         3) &#39;independent&#39;: data0 and data1 are not directly paired, e.g., two groups of people under different treatment</span>

<span class="sd">         4) &#39;paired&#39;: data0 and data1 are directly paired, e.g., the same groups of people before and after treatment</span>

<span class="sd">    :return: d statistic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># determine test type automatically</span>
    <span class="k">if</span> <span class="n">type_test</span><span class="o">==</span><span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">type_test</span> <span class="o">=</span> <span class="s1">&#39;one-sample&#39;</span>
        <span class="k">elif</span> <span class="n">data1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">data0</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">type_test</span> <span class="o">=</span> <span class="s1">&#39;paired&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_test</span> <span class="o">=</span> <span class="s1">&#39;independent&#39;</span>

    <span class="k">if</span> <span class="n">type_test</span> <span class="o">==</span> <span class="s1">&#39;paired&#39;</span><span class="p">:</span>
        <span class="n">data0</span> <span class="o">=</span> <span class="n">data1</span><span class="o">-</span><span class="n">data0</span>
    <span class="k">if</span> <span class="n">type_test</span> <span class="o">==</span> <span class="s1">&#39;paired&#39;</span> <span class="ow">or</span> <span class="n">type_test</span> <span class="o">==</span> <span class="s1">&#39;one-sample&#39;</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="n">data0</span><span class="o">.</span><span class="n">size</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="n">data0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">pooled_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span> <span class="p">(</span><span class="n">n0</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n0</span><span class="o">+</span><span class="n">n1</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">/</span><span class="n">pooled_std</span>
    <span class="k">return</span> <span class="n">d</span></div>



<span class="sd">&quot;&quot;&quot; ===== machine learning related ===== &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LowDimEmbedding"><a class="viewcode-back" href="../index.html#PyNeuroAna.LowDimEmbedding">[docs]</a><span class="k">def</span> <span class="nf">LowDimEmbedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;PCA&#39;</span><span class="p">,</span> <span class="n">para</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Low dimensional embedding of the data, using PCA or manifold leaning method</span>

<span class="sd">    :param data: N*M array, N data points of M dimensions</span>
<span class="sd">    :param type: embedding method</span>
<span class="sd">    :return:     N*2 array, 2D representation of all N data points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span><span class="s1">&#39;PCA&#39;</span><span class="p">:</span>
        <span class="n">para</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="p">(</span><span class="n">para</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">para</span>
        <span class="n">model_embedding</span> <span class="o">=</span>  <span class="n">decomposition</span><span class="o">.</span><span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">para</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span><span class="s1">&#39;ICA&#39;</span><span class="p">:</span>
        <span class="n">model_embedding</span> <span class="o">=</span>  <span class="n">decomposition</span><span class="o">.</span><span class="n">FastICA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;Isomap&#39;</span><span class="p">:</span>
        <span class="n">para</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">para</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">para</span>
        <span class="n">model_embedding</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">Isomap</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">para</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;MDS&#39;</span><span class="p">:</span>
        <span class="n">model_embedding</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">MDS</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;TSNE&#39;</span><span class="p">:</span>
        <span class="n">para</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">para</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">para</span>
        <span class="n">model_embedding</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">para</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;SpectralEmbedding&#39;</span><span class="p">:</span>
        <span class="n">model_embedding</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">SpectralEmbedding</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model_embedding</span> <span class="o">=</span> <span class="n">decomposition</span><span class="o">.</span><span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">result_embedding</span> <span class="o">=</span> <span class="n">model_embedding</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">result_embedding</span> <span class="o">=</span> <span class="n">result_embedding</span><span class="p">[:,</span> <span class="n">result_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">result_embedding</span></div>


<div class="viewcode-block" id="DimRedLDA"><a class="viewcode-back" href="../index.html#PyNeuroAna.DimRedLDA">[docs]</a><span class="k">def</span> <span class="nf">DimRedLDA</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X_test</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lda</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_model</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    supervised dimensionality reduction using LDA</span>

<span class="sd">    :param X:       data, [N*M], required if lda is not given</span>
<span class="sd">    :param Y:       labels, N,   required if lda is not given</span>
<span class="sd">    :param X_test:  testing data [N&#39;*M], default to</span>
<span class="sd">    :param dim:     output dimension</span>
<span class="sd">    :param lda:     model object, if given. the function does not need X, Y to train the model</span>
<span class="sd">    :param return_model: if true returns the trained model, otherwise, returns X_test in low D, [N&#39;*dim]</span>
<span class="sd">    :return:        the model (object) or the testing data in low D  [N&#39;*dim]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">X_test</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X_test</span> <span class="o">=</span> <span class="n">X</span>
    <span class="k">if</span> <span class="n">lda</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lda</span> <span class="o">=</span> <span class="n">LinearDiscriminantAnalysis</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">lda</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
    <span class="n">X_2D</span> <span class="o">=</span> <span class="n">lda</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_model</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lda</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X_2D</span></div>






<span class="sd">&quot;&quot;&quot; ========== Tool functons ========== &quot;&quot;&quot;</span>

<div class="viewcode-block" id="center2edge"><a class="viewcode-back" href="../index.html#PyNeuroAna.center2edge">[docs]</a><span class="k">def</span> <span class="nf">center2edge</span><span class="p">(</span><span class="n">centers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    tool function to get edges from centers for histogram. e.g. [0,1,2] returns [-0.5, 0.5, 1.5, 2.5]</span>

<span class="sd">    :param centers: centers (evenly spaced), 1D array of length N</span>
<span class="sd">    :return:        edges, 1D array of lenth N+1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="ow">is</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span> <span class="o">-</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="index_bool2int"><a class="viewcode-back" href="../index.html#PyNeuroAna.index_bool2int">[docs]</a><span class="k">def</span> <span class="nf">index_bool2int</span><span class="p">(</span><span class="n">index_bool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    tool function to transform bool index to int. e.g. turn [True, False, True] into [0, 2]</span>

<span class="sd">    :param index_bool: bool index, like [True, False, True]</span>
<span class="sd">    :return:           int index, like [0, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">index_bool</span><span class="p">)</span></div>


<div class="viewcode-block" id="index_int2bool"><a class="viewcode-back" href="../index.html#PyNeuroAna.index_int2bool">[docs]</a><span class="k">def</span> <span class="nf">index_int2bool</span><span class="p">(</span><span class="n">index_int</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    tool function to transform int index to bool. e.g. turn into [0, 2] into [True, False, True]</span>

<span class="sd">    :param index_int: int index, like [0, 2]</span>
<span class="sd">    :param N:         length of boolean array</span>
<span class="sd">    :return:          bool index, like [True, False, True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">index_int</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">index_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">index_bool</span><span class="p">[</span><span class="n">index_int</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">index_bool</span><span class="o">&gt;</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="group_shuffle"><a class="viewcode-back" href="../index.html#PyNeuroAna.group_shuffle">[docs]</a><span class="k">def</span> <span class="nf">group_shuffle</span><span class="p">(</span><span class="n">indx_grps</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    controlled shuffle within index groups</span>
<span class="sd">    :param indx_grps: list of indexes, eg. [[0,1,2,3], [4,5,6,7]], will shuffle within [0,1,2,3], and within [4,5,6,7], but not between them</span>
<span class="sd">    :param n:         number of elements to shufflt, defaul to None, s</span>
<span class="sd">    :return:          shuffled index, e.g. [0,3,1,2,5,4,7,6]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">indx_grps</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">indx_shuffle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">indx_grps</span><span class="p">:</span>
        <span class="n">indx_shuffle</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indx_shuffle</span></div>


<div class="viewcode-block" id="group_shuffle_data"><a class="viewcode-back" href="../index.html#PyNeuroAna.group_shuffle_data">[docs]</a><span class="k">def</span> <span class="nf">group_shuffle_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indx_grps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    controlled shuffle within index groups</span>
<span class="sd">    :param data:      data to be shuffled along an axis</span>
<span class="sd">    :param indx_grps: list of indexes, eg. [[0,1,2,3], [4,5,6,7]], will shuffle within [0,1,2,3], and within [4,5,6,7], but not between them</span>
<span class="sd">    :param axis:      along which to shuffle data</span>
<span class="sd">    :return:          shuffled data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">indx_grps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># shuffle all if not given</span>
        <span class="n">indx_grps</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">indx_shuffle</span> <span class="o">=</span> <span class="n">group_shuffle</span><span class="p">(</span><span class="n">indx_grps</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">data_shuffle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indx_shuffle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_shuffle</span></div>



<span class="sd">&quot;&quot;&quot; ========== obsolete functions ========== &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GP_ERP_smooth"><a class="viewcode-back" href="../index.html#PyNeuroAna.GP_ERP_smooth">[docs]</a><span class="k">def</span> <span class="nf">GP_ERP_smooth</span><span class="p">(</span><span class="n">lfp</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; obsolete function,  use gaussian process to smooth data, does not work well &quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">gaussian_process</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">RBF</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">lfp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">gaussian_process</span><span class="o">.</span><span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">N</span><span class="p">,</span><span class="n">T</span> <span class="o">=</span> <span class="n">lfp</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">c_grid</span><span class="p">,</span> <span class="n">t_grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">c_grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">c_grid_sm</span> <span class="o">=</span> <span class="n">c_grid</span>
    <span class="n">x_sm</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">lfp_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c_grid_sm</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_grid</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_grid</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">lfp</span><span class="p">[:,</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">lfp_smooth</span><span class="p">[:,</span><span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_sm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lfp_smooth</span></div>


<div class="viewcode-block" id="quad_smooth_der"><a class="viewcode-back" href="../index.html#PyNeuroAna.quad_smooth_der">[docs]</a><span class="k">def</span> <span class="nf">quad_smooth_der</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">lambda_dev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lambda_der</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">add_edge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">degree_der</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">return_CSD</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --- OBSOLETE: use lfp_robust_smooth instead ---</span>
<span class="sd">    Quadratic smoothing using continuous (2nd-order) derivative assumption, used to calculate csd from lfp with noise</span>

<span class="sd">    :param target:     target signal to smooth, 1D array (recorded lfp with noise, e.g. slightly different gain between channels)</span>
<span class="sd">    :param lambda_dev: coefficient of the deviation  for the cost term, scalar or vector of the same shape as the target.  if target[i] is noisy, set lambda_dev[i] to be close to zero</span>
<span class="sd">    :param lambda_der: coefficient of the derivative for the cost term.  Larger values leads to more smoothed data</span>
<span class="sd">    :param add_edge:   number of channels to add outside both edges, to prevent boundary effect during computation (will be removed in result)</span>
<span class="sd">    :param return_CSD: true/false to return csd, affect the returned result</span>
<span class="sd">    :param x0:         initial value for optimization, default to None</span>
<span class="sd">    :return:           target_smoothed, or (target smoothed, csd)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lambda_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lambda_dev</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">quad_cost</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; cost function where x is the variable and y is the target; penalize when 1) x devetates from y and 2) x is not smooth &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot; dev (deviation) term: the smoothed data has to be similar with the original target data &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">add_edge</span><span class="p">:</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">add_edge</span><span class="p">:</span><span class="mi">0</span><span class="o">-</span><span class="n">add_edge</span><span class="p">]</span><span class="o">-</span><span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span>
        <span class="sd">&quot;&quot;&quot; der (derivative) term: the smoothed data has to be smooth &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">degree_der</span> <span class="o">==</span><span class="mi">3</span><span class="p">:</span>     <span class="c1"># if assuming 3rd derivative is small, i.e., smooth 2nd derivative (csd from lfp)</span>
            <span class="n">der</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>   <span class="c1"># third order derivative</span>
        <span class="k">elif</span> <span class="n">degree_der</span> <span class="o">==</span><span class="mi">4</span><span class="p">:</span>   <span class="c1"># if assuming 4th derivative is small, i.e., smooth 3rd derivative</span>
            <span class="n">der</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>   <span class="c1"># fourth order derivative</span>
        <span class="sd">&quot;&quot;&quot; tocal cost is the summation of dev and der &quot;&quot;&quot;</span>
        <span class="n">cost</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lambda_dev</span><span class="o">*</span> <span class="n">dev</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">lambda_der</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">der</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span>

    <span class="sd">&quot;&quot;&quot; add edge to x0, initial values for optimization &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">add_edge</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">add_edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>

    <span class="sd">&quot;&quot;&quot; optimization step &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">quad_cost</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">target</span><span class="p">),</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">add_edge</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">add_edge</span><span class="p">:</span><span class="mi">0</span><span class="o">-</span><span class="n">add_edge</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_CSD</span><span class="p">:</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="n">csd</span><span class="p">[</span><span class="n">add_edge</span><span class="p">:</span><span class="mi">0</span><span class="o">-</span><span class="n">add_edge</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="p">,</span> <span class="n">csd</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
        <span class="k">if</span> <span class="n">return_CSD</span><span class="p">:</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="n">csd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="p">,</span> <span class="n">csd</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="lfp_cross_chan_smooth"><a class="viewcode-back" href="../index.html#PyNeuroAna.lfp_cross_chan_smooth">[docs]</a><span class="k">def</span> <span class="nf">lfp_cross_chan_smooth</span><span class="p">(</span><span class="n">lfp</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;der&#39;</span><span class="p">,</span> <span class="n">lambda_dev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lambda_der</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma_chan</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sigma_t</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tf_x0</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --- OBSOLETE: use lfp_robust_smooth instead ---</span>
<span class="sd">    Smooth the lfp across channels for csd estimation, to deal with varied gain across channels. either use 1) derivative-based method or 2) gaussian filter</span>

<span class="sd">    1) derivative-based: Quadratic smoothing using continuous (2nd-order) derivative assumption across channels, see function quad_smooth_der for details</span>

<span class="sd">    2) gaussian filter: use gaussian filter to smooth lfp across channels</span>

<span class="sd">    :param lfp:        lfp signal, [num_chan, num_timestamps]</span>
<span class="sd">    :param method:     smoothing method: &#39;der&#39; for derivative-based method; &#39;gaussian&#39; for gaussian filter</span>
<span class="sd">    :param lambda_dev: coefficient of the deviation  for the cost term, scalar or vector of the same shape as the target.  if target[i] is noisy, set lambda_dev[i] small or just zero, used for &#39;der&#39; method</span>
<span class="sd">    :param lambda_der: coefficient of the derivative for the cost term.  Larger values leads to more smoothed result, used for &#39;der&#39; method</span>
<span class="sd">    :param sigma_chan: std for gaussian smoothing across channels, used for &#39;gaussian&#39; method</span>
<span class="sd">    :param sigma_t:    std for gaussian smoothing along time axis, set to 0 if do not smooth along time</span>
<span class="sd">    :param tf_x0:      true/false using the result of previous time point as the initial point for optimization, defult to True, which speeds up computation</span>
<span class="sd">    :return:           lfp of the same shape, smoothed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">lfp</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">lfp_hat</span> <span class="o">=</span> <span class="n">lfp</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">scale_lfp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lfp</span><span class="p">),</span> <span class="mi">98</span><span class="p">)</span>    <span class="c1"># used to normalize the data, convenient for optimization</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;der&#39;</span><span class="p">:</span>
        <span class="n">x0</span><span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">lfp</span><span class="p">[:,</span><span class="n">t</span><span class="p">]</span><span class="o">/</span><span class="n">scale_lfp</span>
            <span class="n">x_smooth</span> <span class="o">=</span> <span class="n">quad_smooth_der</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lambda_dev</span><span class="o">=</span><span class="n">lambda_dev</span><span class="p">,</span> <span class="n">lambda_der</span><span class="o">=</span><span class="n">lambda_der</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">add_edge</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">lfp_hat</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_smooth</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">x_smooth</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span><span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">lfp_hat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">lfp</span><span class="o">/</span><span class="n">scale_lfp</span><span class="p">,</span> <span class="n">sigma_chan</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;method has to be either &quot;der&quot; or &quot;gaussian&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sigma_t</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">lfp_hat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">lfp_hat</span><span class="p">,</span> <span class="n">sigma_t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lfp_hat</span> <span class="o">*</span> <span class="n">scale_lfp</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Shaobo Guan, Ruobing Xia.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>